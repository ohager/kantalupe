// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#ifndef XRS_HXX
#define XRS_HXX

#include <xsde/cxx/version.hxx>

#if (XSDE_INT_VERSION != 3020000L)
#error XSD/e runtime version mismatch
#endif

#include <xsde/cxx/config.hxx>

#ifndef XSDE_ENCODING_UTF8
#error the generated code uses the UTF-8 encodingwhile the XSD/e runtime does not (reconfigure the runtime or change the --char-encoding value)
#endif

#ifndef XSDE_STL
#error the generated code uses STL while the XSD/e runtime does not (reconfigure the runtime or add --no-stl)
#endif

#ifndef XSDE_EXCEPTIONS
#error the generated code uses exceptions while the XSD/e runtime does not (reconfigure the runtime or add --no-exceptions)
#endif

#ifdef XSDE_LONGLONG
#error the XSD/e runtime uses long long while the generated code does not (reconfigure the runtime or remove --no-long-long)
#endif

#ifdef XSDE_CUSTOM_ALLOCATOR
#error the XSD/e runtime uses custom allocator while the generated code does not (reconfigure the runtime or add --custom-allocator)
#endif

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include <string>
#include <xsde/cxx/hybrid/xml-schema.hxx>
#include <xsde/cxx/hybrid/sequence.hxx>

namespace xml_schema
{
  using ::xsde::cxx::hybrid::any_type;
  typedef ::std::string any_simple_type;

  typedef signed char byte;
  using ::xsde::cxx::hybrid::byte_base;

  typedef unsigned char unsigned_byte;
  using ::xsde::cxx::hybrid::unsigned_byte_base;

  typedef short short_;
  using ::xsde::cxx::hybrid::short_base;

  typedef unsigned short unsigned_short;
  using ::xsde::cxx::hybrid::unsigned_short_base;

  typedef int int_;
  using ::xsde::cxx::hybrid::int_base;

  typedef unsigned int unsigned_int;
  using ::xsde::cxx::hybrid::unsigned_int_base;

  typedef long long_;
  using ::xsde::cxx::hybrid::long_base;

  typedef unsigned long unsigned_long;
  using ::xsde::cxx::hybrid::unsigned_long_base;

  typedef long integer;
  using ::xsde::cxx::hybrid::integer_base;

  typedef long non_positive_integer;
  using ::xsde::cxx::hybrid::non_positive_integer_base;

  typedef unsigned long non_negative_integer;
  using ::xsde::cxx::hybrid::non_negative_integer_base;

  typedef unsigned long positive_integer;
  using ::xsde::cxx::hybrid::positive_integer_base;

  typedef long negative_integer;
  using ::xsde::cxx::hybrid::negative_integer_base;

  typedef bool boolean;
  using ::xsde::cxx::hybrid::boolean_base;

  typedef float float_;
  using ::xsde::cxx::hybrid::float_base;

  typedef double double_;
  using ::xsde::cxx::hybrid::double_base;

  typedef double decimal;
  using ::xsde::cxx::hybrid::decimal_base;

  typedef ::std::string string;

  typedef ::std::string normalized_string;

  typedef ::std::string token;

  typedef ::std::string name;

  typedef ::std::string nmtoken;

  typedef ::xsde::cxx::string_sequence nmtokens;

  typedef ::std::string ncname;

  typedef ::std::string language;

  typedef ::std::string id;

  typedef ::std::string idref;

  typedef ::xsde::cxx::string_sequence idrefs;

  typedef ::std::string uri;

  using ::xsde::cxx::qname;

  using ::xsde::cxx::buffer;
  typedef ::xsde::cxx::buffer base64_binary;
  typedef ::xsde::cxx::buffer hex_binary;

  using ::xsde::cxx::time_zone;
  using ::xsde::cxx::date;
  using ::xsde::cxx::date_time;
  using ::xsde::cxx::duration;
  using ::xsde::cxx::gday;
  using ::xsde::cxx::gmonth;
  using ::xsde::cxx::gmonth_day;
  using ::xsde::cxx::gyear;
  using ::xsde::cxx::gyear_month;
  using ::xsde::cxx::time;

  using ::xsde::cxx::hybrid::pod_sequence;
  using ::xsde::cxx::hybrid::fix_sequence;
  using ::xsde::cxx::hybrid::var_sequence;
  using ::xsde::cxx::string_sequence;
  using ::xsde::cxx::hybrid::data_sequence;
}

class ResourceTypes;
class xrs;
class Resource;
class ResourceSet;

#ifndef XSDE_DONT_INCLUDE_INLINE
#define XSDE_DONT_INCLUDE_INLINE

#undef XSDE_DONT_INCLUDE_INLINE
#else

#endif // XSDE_DONT_INCLUDE_INLINE

// ResourceTypes (fixed-length)
//
class ResourceTypes
{
  public:
  enum value_type
  {
    file,
    image,
    text
  };

  ResourceTypes ();
  ResourceTypes (value_type);

  void
  value (value_type);

  operator value_type () const
  {
    return value_;
  }

  const char*
  string () const;

  private:
  value_type value_;
};

// xrs (variable-length)
//
class xrs
{
  private:
  xrs (const xrs&);
  xrs& operator= (const xrs&);

  public:
  xrs ();

  ~xrs ();

  // id
  //
  const ::std::string&
  id () const;

  ::std::string&
  id ();

  void
  id (const ::std::string&);

  // version
  //
  const ::std::string&
  version () const;

  ::std::string&
  version ();

  void
  version (const ::std::string&);

  // ResourceSet
  //
  typedef ::xsde::cxx::hybrid::var_sequence< ::ResourceSet > ResourceSet_sequence;
  typedef ResourceSet_sequence::iterator ResourceSet_iterator;
  typedef ResourceSet_sequence::const_iterator ResourceSet_const_iterator;

  const ResourceSet_sequence&
  ResourceSet () const;

  ResourceSet_sequence&
  ResourceSet ();

  private:
  ::std::string id_;
  ::std::string version_;
  ResourceSet_sequence ResourceSet_;
};

// Resource (fixed-length)
//
class Resource: public ::std::string
{
  public:
  Resource ();

  Resource (const Resource&);
  Resource& operator= (const Resource&);

  ~Resource ();

  // type
  //
  const ::ResourceTypes&
  type () const;

  ::ResourceTypes&
  type ();

  void
  type (const ::ResourceTypes&);

  // alias
  //
  const ::std::string&
  alias () const;

  ::std::string&
  alias ();

  void
  alias (const ::std::string&);

  private:
  ::ResourceTypes type_;
  ::std::string alias_;
};

// ResourceSet (variable-length)
//
class ResourceSet
{
  private:
  ResourceSet (const ResourceSet&);
  ResourceSet& operator= (const ResourceSet&);

  public:
  ResourceSet ();

  ~ResourceSet ();

  // prefix
  //
  const ::std::string&
  prefix () const;

  ::std::string&
  prefix ();

  void
  prefix (const ::std::string&);

  // Resource
  //
  typedef ::xsde::cxx::hybrid::fix_sequence< ::Resource > Resource_sequence;
  typedef Resource_sequence::iterator Resource_iterator;
  typedef Resource_sequence::const_iterator Resource_const_iterator;

  const Resource_sequence&
  Resource () const;

  Resource_sequence&
  Resource ();

  private:
  ::std::string prefix_;
  Resource_sequence Resource_;
};

#ifndef XSDE_DONT_INCLUDE_INLINE

#endif // XSDE_DONT_INCLUDE_INLINE

#ifndef XSDE_DONT_INCLUDE_INLINE
#include "xrs.ixx"
#endif // XSDE_DONT_INCLUDE_INLINE

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

#endif // XRS_HXX
