// Copyright (C) 2005-2009 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include "kmodel2-pskel.hxx"

#include <assert.h>

// LabelType_pskel
//

void LabelType_pskel::
id (unsigned int x)
{
  if (this->LabelType_impl_)
    this->LabelType_impl_->id (x);
}

void LabelType_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  this->v_state_attr_stack_.clear ();

  if (this->id_parser_)
    this->id_parser_->_reset ();
}

::std::string LabelType_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// Property_pskel
//

void Property_pskel::
key (const ::std::string& x)
{
  if (this->Property_impl_)
    this->Property_impl_->key (x);
}

void Property_pskel::
value (const ::std::string& x)
{
  if (this->Property_impl_)
    this->Property_impl_->value (x);
}

void Property_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  this->v_state_attr_stack_.clear ();

  if (this->key_parser_)
    this->key_parser_->_reset ();

  if (this->value_parser_)
    this->value_parser_->_reset ();
}

::std::string Property_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// PropertyListType_pskel
//

void PropertyListType_pskel::
Property (const ::Property& x)
{
  if (this->PropertyListType_impl_)
    this->PropertyListType_impl_->Property (x);
}

void PropertyListType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->Property_parser_)
    this->Property_parser_->_reset ();

  this->resetting_ = false;
}

// jProposalType_pskel
//

void jProposalType_pskel::
mc (bool x)
{
  if (this->jProposalType_impl_)
    this->jProposalType_impl_->mc (x);
}

void jProposalType_pskel::
qname (const ::std::string& x)
{
  if (this->jProposalType_impl_)
    this->jProposalType_impl_->qname (x);
}

void jProposalType_pskel::
Label (const ::LabelType& x)
{
  if (this->jProposalType_impl_)
    this->jProposalType_impl_->Label (x);
}

void jProposalType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->v_state_attr_stack_.clear ();

  if (this->mc_parser_)
    this->mc_parser_->_reset ();

  if (this->qname_parser_)
    this->qname_parser_->_reset ();

  this->resetting_ = true;

  if (this->Label_parser_)
    this->Label_parser_->_reset ();

  this->resetting_ = false;
}

// Image_pskel
//

void Image_pskel::
id (unsigned int x)
{
  if (this->Image_impl_)
    this->Image_impl_->id (x);
}

void Image_pskel::
uri (const ::std::string& x)
{
  if (this->Image_impl_)
    this->Image_impl_->uri (x);
}

void Image_pskel::
_reset ()
{
  typedef ::xml_schema::string_pskel base;
  base::_reset ();

  this->v_state_attr_stack_.clear ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->uri_parser_)
    this->uri_parser_->_reset ();
}

::std::string Image_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

// ImageListType_pskel
//

void ImageListType_pskel::
Image (const ::Image& x)
{
  if (this->ImageListType_impl_)
    this->ImageListType_impl_->Image (x);
}

void ImageListType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->Image_parser_)
    this->Image_parser_->_reset ();

  this->resetting_ = false;
}

// jGroupType_pskel
//

void jGroupType_pskel::
id (unsigned int x)
{
  if (this->jGroupType_impl_)
    this->jGroupType_impl_->id (x);
}

void jGroupType_pskel::
name (const ::std::string& x)
{
  if (this->jGroupType_impl_)
    this->jGroupType_impl_->name (x);
}

void jGroupType_pskel::
PropertyList (::PropertyListType* x)
{
  if (this->jGroupType_impl_)
    this->jGroupType_impl_->PropertyList (x);
}

void jGroupType_pskel::
SourceList (::SourceList* x)
{
  if (this->jGroupType_impl_)
    this->jGroupType_impl_->SourceList (x);
}

void jGroupType_pskel::
Description (const ::std::string& x)
{
  if (this->jGroupType_impl_)
    this->jGroupType_impl_->Description (x);
}

void jGroupType_pskel::
ImageList (::ImageListType* x)
{
  if (this->jGroupType_impl_)
    this->jGroupType_impl_->ImageList (x);
}

void jGroupType_pskel::
Text (const ::std::string& x)
{
  if (this->jGroupType_impl_)
    this->jGroupType_impl_->Text (x);
}

void jGroupType_pskel::
Hint (const ::std::string& x)
{
  if (this->jGroupType_impl_)
    this->jGroupType_impl_->Hint (x);
}

void jGroupType_pskel::
jProposal (::jProposal* x)
{
  if (this->jGroupType_impl_)
    this->jGroupType_impl_->jProposal (x);
}

void jGroupType_pskel::
jProblemList (::jProblemList* x)
{
  if (this->jGroupType_impl_)
    this->jGroupType_impl_->jProblemList (x);
}

void jGroupType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->v_state_attr_stack_.clear ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->name_parser_)
    this->name_parser_->_reset ();

  this->resetting_ = true;

  if (this->PropertyList_parser_)
    this->PropertyList_parser_->_reset ();

  if (this->SourceList_parser_)
    this->SourceList_parser_->_reset ();

  if (this->Description_parser_)
    this->Description_parser_->_reset ();

  if (this->ImageList_parser_)
    this->ImageList_parser_->_reset ();

  if (this->Text_parser_)
    this->Text_parser_->_reset ();

  if (this->Hint_parser_)
    this->Hint_parser_->_reset ();

  if (this->jProposal_parser_)
    this->jProposal_parser_->_reset ();

  if (this->jProblemList_parser_)
    this->jProblemList_parser_->_reset ();

  this->resetting_ = false;
}

// CategoryType_pskel
//

void CategoryType_pskel::
id (unsigned long x)
{
  if (this->CategoryType_impl_)
    this->CategoryType_impl_->id (x);
}

void CategoryType_pskel::
name (const ::std::string& x)
{
  if (this->CategoryType_impl_)
    this->CategoryType_impl_->name (x);
}

void CategoryType_pskel::
PropertyList (::PropertyListType* x)
{
  if (this->CategoryType_impl_)
    this->CategoryType_impl_->PropertyList (x);
}

void CategoryType_pskel::
Description (const ::std::string& x)
{
  if (this->CategoryType_impl_)
    this->CategoryType_impl_->Description (x);
}

void CategoryType_pskel::
Category (::CategoryType* x)
{
  if (this->CategoryType_impl_)
    this->CategoryType_impl_->Category (x);
}

void CategoryType_pskel::
jGroup (::jGroupType* x)
{
  if (this->CategoryType_impl_)
    this->CategoryType_impl_->jGroup (x);
}

void CategoryType_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->v_state_attr_stack_.clear ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  if (this->name_parser_)
    this->name_parser_->_reset ();

  this->resetting_ = true;

  if (this->PropertyList_parser_)
    this->PropertyList_parser_->_reset ();

  if (this->Description_parser_)
    this->Description_parser_->_reset ();

  if (this->Category_parser_)
    this->Category_parser_->_reset ();

  if (this->jGroup_parser_)
    this->jGroup_parser_->_reset ();

  this->resetting_ = false;
}

// SourceRef_pskel
//

void SourceRef_pskel::
qnameref (const ::std::string& x)
{
  if (this->SourceRef_impl_)
    this->SourceRef_impl_->qnameref (x);
}

void SourceRef_pskel::
_reset ()
{
  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  if (this->qnameref_parser_)
    this->qnameref_parser_->_reset ();
}

// SourceList_pskel
//

void SourceList_pskel::
SourceRef (const ::SourceRef& x)
{
  if (this->SourceList_impl_)
    this->SourceList_impl_->SourceRef (x);
}

void SourceList_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->SourceRef_parser_)
    this->SourceRef_parser_->_reset ();

  this->resetting_ = false;
}

// jProposalRef_pskel
//

void jProposalRef_pskel::
qnameref (const ::std::string& x)
{
  if (this->jProposalRef_impl_)
    this->jProposalRef_impl_->qnameref (x);
}

void jProposalRef_pskel::
_reset ()
{
  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_attr_stack_.clear ();

  if (this->qnameref_parser_)
    this->qnameref_parser_->_reset ();
}

// jProposal_pskel
//

void jProposal_pskel::
jProposalRef (const ::jProposalRef& x)
{
  if (this->jProposal_impl_)
    this->jProposal_impl_->jProposalRef (x);
}

void jProposal_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::jProposalType_pskel base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->jProposalRef_parser_)
    this->jProposalRef_parser_->_reset ();

  this->resetting_ = false;
}

::jProposalType* jProposal_pskel::
post_jProposalType ()
{
  assert (this->jProposalType_impl_);
  return this->jProposalType_impl_->post_jProposalType ();
}

// jProblemList_pskel
//

void jProblemList_pskel::
jProblem (::jProblem* x)
{
  if (this->jProblemList_impl_)
    this->jProblemList_impl_->jProblem (x);
}

void jProblemList_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->jProblem_parser_)
    this->jProblem_parser_->_reset ();

  this->resetting_ = false;
}

// kmx_pskel
//

void kmx_pskel::
name (const ::std::string& x)
{
  if (this->kmx_impl_)
    this->kmx_impl_->name (x);
}

void kmx_pskel::
version (const ::std::string& x)
{
  if (this->kmx_impl_)
    this->kmx_impl_->version (x);
}

void kmx_pskel::
References (::References* x)
{
  if (this->kmx_impl_)
    this->kmx_impl_->References (x);
}

void kmx_pskel::
Content (::Content* x)
{
  if (this->kmx_impl_)
    this->kmx_impl_->Content (x);
}

void kmx_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->v_state_attr_stack_.clear ();

  if (this->name_parser_)
    this->name_parser_->_reset ();

  if (this->version_parser_)
    this->version_parser_->_reset ();

  this->resetting_ = true;

  if (this->References_parser_)
    this->References_parser_->_reset ();

  if (this->Content_parser_)
    this->Content_parser_->_reset ();

  this->resetting_ = false;
}

// Solution_pskel
//

void Solution_pskel::
idref (unsigned int x)
{
  if (this->Solution_impl_)
    this->Solution_impl_->idref (x);
}

void Solution_pskel::
_reset ()
{
  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  if (this->idref_parser_)
    this->idref_parser_->_reset ();
}

// jProblem_pskel
//

void jProblem_pskel::
id (unsigned int x)
{
  if (this->jProblem_impl_)
    this->jProblem_impl_->id (x);
}

void jProblem_pskel::
PropertyList (::PropertyListType* x)
{
  if (this->jProblem_impl_)
    this->jProblem_impl_->PropertyList (x);
}

void jProblem_pskel::
Text (const ::std::string& x)
{
  if (this->jProblem_impl_)
    this->jProblem_impl_->Text (x);
}

void jProblem_pskel::
Solution (const ::Solution& x)
{
  if (this->jProblem_impl_)
    this->jProblem_impl_->Solution (x);
}

void jProblem_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->v_state_attr_stack_.clear ();

  if (this->id_parser_)
    this->id_parser_->_reset ();

  this->resetting_ = true;

  if (this->PropertyList_parser_)
    this->PropertyList_parser_->_reset ();

  if (this->Text_parser_)
    this->Text_parser_->_reset ();

  if (this->Solution_parser_)
    this->Solution_parser_->_reset ();

  this->resetting_ = false;
}

// References_pskel
//

void References_pskel::
RefSourceList (::RefSourceList* x)
{
  if (this->References_impl_)
    this->References_impl_->RefSourceList (x);
}

void References_pskel::
RefProposalTypeList (::RefProposalTypeList* x)
{
  if (this->References_impl_)
    this->References_impl_->RefProposalTypeList (x);
}

void References_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->RefSourceList_parser_)
    this->RefSourceList_parser_->_reset ();

  if (this->RefProposalTypeList_parser_)
    this->RefProposalTypeList_parser_->_reset ();

  this->resetting_ = false;
}

// Content_pskel
//

void Content_pskel::
Category (::CategoryType* x)
{
  if (this->Content_impl_)
    this->Content_impl_->Category (x);
}

void Content_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->Category_parser_)
    this->Category_parser_->_reset ();

  this->resetting_ = false;
}

// RefSourceList_pskel
//

void RefSourceList_pskel::
Source (::Source* x)
{
  if (this->RefSourceList_impl_)
    this->RefSourceList_impl_->Source (x);
}

void RefSourceList_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->Source_parser_)
    this->Source_parser_->_reset ();

  this->resetting_ = false;
}

// RefProposalTypeList_pskel
//

void RefProposalTypeList_pskel::
jProposalList (::jProposalList* x)
{
  if (this->RefProposalTypeList_impl_)
    this->RefProposalTypeList_impl_->jProposalList (x);
}

void RefProposalTypeList_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->jProposalList_parser_)
    this->jProposalList_parser_->_reset ();

  this->resetting_ = false;
}

// Source_pskel
//

void Source_pskel::
qname (const ::std::string& x)
{
  if (this->Source_impl_)
    this->Source_impl_->qname (x);
}

void Source_pskel::
uri (const ::std::string& x)
{
  if (this->Source_impl_)
    this->Source_impl_->uri (x);
}

void Source_pskel::
PropertyList (::PropertyListType* x)
{
  if (this->Source_impl_)
    this->Source_impl_->PropertyList (x);
}

void Source_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->v_state_attr_stack_.clear ();

  if (this->qname_parser_)
    this->qname_parser_->_reset ();

  if (this->uri_parser_)
    this->uri_parser_->_reset ();

  this->resetting_ = true;

  if (this->PropertyList_parser_)
    this->PropertyList_parser_->_reset ();

  this->resetting_ = false;
}

// jProposalList_pskel
//

void jProposalList_pskel::
jProposal (::jProposalType* x)
{
  if (this->jProposalList_impl_)
    this->jProposalList_impl_->jProposal (x);
}

void jProposalList_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->jProposal_parser_)
    this->jProposal_parser_->_reset ();

  this->resetting_ = false;
}

#include <assert.h>

// Element validation and dispatch functions for PropertyListType_pskel.
//
bool PropertyListType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "Property" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &PropertyListType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool PropertyListType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void PropertyListType_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void PropertyListType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void PropertyListType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "Property" && ns.empty ())
      {
        if (start)
        {
          if (this->Property_parser_)
          {
            this->Property_parser_->pre ();
            this->Property_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->Property_parser_)
          {
            const ::Property& tmp = this->Property_parser_->post_Property ();
            this->Property (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for jProposalType_pskel.
//
bool jProposalType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "Label" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &jProposalType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool jProposalType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void jProposalType_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void jProposalType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void jProposalType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "Label" && ns.empty ())
      {
        if (start)
        {
          if (this->Label_parser_)
          {
            this->Label_parser_->pre ();
            this->Label_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->Label_parser_)
          {
            const ::LabelType& tmp = this->Label_parser_->post_LabelType ();
            this->Label (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for ImageListType_pskel.
//
bool ImageListType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "Image" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &ImageListType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool ImageListType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void ImageListType_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void ImageListType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void ImageListType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "Image" && ns.empty ())
      {
        if (start)
        {
          if (this->Image_parser_)
          {
            this->Image_parser_->pre ();
            this->Image_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->Image_parser_)
          {
            const ::Image& tmp = this->Image_parser_->post_Image ();
            this->Image (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for jGroupType_pskel.
//
bool jGroupType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "PropertyList" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &jGroupType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool jGroupType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void jGroupType_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void jGroupType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void jGroupType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "PropertyList" && ns.empty ())
      {
        if (start)
        {
          if (this->PropertyList_parser_)
          {
            this->PropertyList_parser_->pre ();
            this->PropertyList_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->PropertyList_parser_)
          {
            ::PropertyListType* tmp = this->PropertyList_parser_->post_PropertyListType ();
            this->PropertyList (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "SourceList" && ns.empty ())
      {
        if (start)
        {
          if (this->SourceList_parser_)
          {
            this->SourceList_parser_->pre ();
            this->SourceList_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->SourceList_parser_)
          {
            ::SourceList* tmp = this->SourceList_parser_->post_SourceList ();
            this->SourceList (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "Description" && ns.empty ())
      {
        if (start)
        {
          if (this->Description_parser_)
          {
            this->Description_parser_->pre ();
            this->Description_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->Description_parser_)
          {
            const ::std::string& tmp = this->Description_parser_->post_string ();
            this->Description (tmp);
          }

          count = 0;
          state = 3UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 3UL;
        // Fall through.
      }
    }
    case 3UL:
    {
      if (n == "ImageList" && ns.empty ())
      {
        if (start)
        {
          if (this->ImageList_parser_)
          {
            this->ImageList_parser_->pre ();
            this->ImageList_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->ImageList_parser_)
          {
            ::ImageListType* tmp = this->ImageList_parser_->post_ImageListType ();
            this->ImageList (tmp);
          }

          count = 0;
          state = 4UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 4UL;
        // Fall through.
      }
    }
    case 4UL:
    {
      if (n == "Text" && ns.empty ())
      {
        if (start)
        {
          if (this->Text_parser_)
          {
            this->Text_parser_->pre ();
            this->Text_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->Text_parser_)
          {
            const ::std::string& tmp = this->Text_parser_->post_string ();
            this->Text (tmp);
          }

          count = 0;
          state = 5UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 5UL;
        // Fall through.
      }
    }
    case 5UL:
    {
      if (n == "Hint" && ns.empty ())
      {
        if (start)
        {
          if (this->Hint_parser_)
          {
            this->Hint_parser_->pre ();
            this->Hint_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->Hint_parser_)
          {
            const ::std::string& tmp = this->Hint_parser_->post_string ();
            this->Hint (tmp);
          }

          count = 0;
          state = 6UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 6UL;
        // Fall through.
      }
    }
    case 6UL:
    {
      if (n == "jProposal" && ns.empty ())
      {
        if (start)
        {
          if (this->jProposal_parser_)
          {
            this->jProposal_parser_->pre ();
            this->jProposal_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->jProposal_parser_)
          {
            ::jProposal* tmp = this->jProposal_parser_->post_jProposal ();
            this->jProposal (tmp);
          }

          count = 0;
          state = 7UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 7UL;
        // Fall through.
      }
    }
    case 7UL:
    {
      if (n == "jProblemList" && ns.empty ())
      {
        if (start)
        {
          if (this->jProblemList_parser_)
          {
            this->jProblemList_parser_->pre ();
            this->jProblemList_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->jProblemList_parser_)
          {
            ::jProblemList* tmp = this->jProblemList_parser_->post_jProblemList ();
            this->jProblemList (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for CategoryType_pskel.
//
bool CategoryType_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "PropertyList" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &CategoryType_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool CategoryType_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void CategoryType_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void CategoryType_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void CategoryType_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "PropertyList" && ns.empty ())
      {
        if (start)
        {
          if (this->PropertyList_parser_)
          {
            this->PropertyList_parser_->pre ();
            this->PropertyList_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->PropertyList_parser_)
          {
            ::PropertyListType* tmp = this->PropertyList_parser_->post_PropertyListType ();
            this->PropertyList (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "Description" && ns.empty ())
      {
        if (start)
        {
          if (this->Description_parser_)
          {
            this->Description_parser_->pre ();
            this->Description_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->Description_parser_)
          {
            const ::std::string& tmp = this->Description_parser_->post_string ();
            this->Description (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "Category" && ns.empty ())
      {
        if (start)
        {
          if (this->Category_parser_)
          {
            this->Category_parser_->pre ();
            this->Category_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->Category_parser_)
          {
            ::CategoryType* tmp = this->Category_parser_->post_CategoryType ();
            this->Category (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 3UL;
        // Fall through.
      }
    }
    case 3UL:
    {
      if (n == "jGroup" && ns.empty ())
      {
        if (start)
        {
          if (this->jGroup_parser_)
          {
            this->jGroup_parser_->pre ();
            this->jGroup_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->jGroup_parser_)
          {
            ::jGroupType* tmp = this->jGroup_parser_->post_jGroupType ();
            this->jGroup (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for SourceList_pskel.
//
bool SourceList_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "SourceRef" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &SourceList_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool SourceList_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void SourceList_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void SourceList_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void SourceList_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "SourceRef" && ns.empty ())
      {
        if (start)
        {
          if (this->SourceRef_parser_)
          {
            this->SourceRef_parser_->pre ();
            this->SourceRef_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->SourceRef_parser_)
          {
            const ::SourceRef& tmp = this->SourceRef_parser_->post_SourceRef ();
            this->SourceRef (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for jProposal_pskel.
//
bool jProposal_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::jProposalType_pskel base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "jProposalRef" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &jProposal_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool jProposal_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::jProposalType_pskel base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void jProposal_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
  typedef ::jProposalType_pskel base;
  base::_pre_e_validate ();
}

void jProposal_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  typedef ::jProposalType_pskel base;
  base::_post_e_validate ();

  if (ctx.error_type ())
    return;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void jProposal_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "jProposalRef" && ns.empty ())
      {
        if (start)
        {
          if (this->jProposalRef_parser_)
          {
            this->jProposalRef_parser_->pre ();
            this->jProposalRef_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->jProposalRef_parser_)
          {
            const ::jProposalRef& tmp = this->jProposalRef_parser_->post_jProposalRef ();
            this->jProposalRef (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for jProblemList_pskel.
//
bool jProblemList_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "jProblem" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &jProblemList_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool jProblemList_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void jProblemList_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void jProblemList_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void jProblemList_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "jProblem" && ns.empty ())
      {
        if (start)
        {
          if (this->jProblem_parser_)
          {
            this->jProblem_parser_->pre ();
            this->jProblem_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->jProblem_parser_)
          {
            ::jProblem* tmp = this->jProblem_parser_->post_jProblem ();
            this->jProblem (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for kmx_pskel.
//
bool kmx_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "References" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &kmx_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool kmx_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void kmx_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void kmx_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void kmx_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "References" && ns.empty ())
      {
        if (start)
        {
          if (this->References_parser_)
          {
            this->References_parser_->pre ();
            this->References_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->References_parser_)
          {
            ::References* tmp = this->References_parser_->post_References ();
            this->References (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "Content" && ns.empty ())
      {
        if (start)
        {
          if (this->Content_parser_)
          {
            this->Content_parser_->pre ();
            this->Content_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->Content_parser_)
          {
            ::Content* tmp = this->Content_parser_->post_Content ();
            this->Content (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for jProblem_pskel.
//
bool jProblem_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "PropertyList" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &jProblem_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool jProblem_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void jProblem_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void jProblem_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void jProblem_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "PropertyList" && ns.empty ())
      {
        if (start)
        {
          if (this->PropertyList_parser_)
          {
            this->PropertyList_parser_->pre ();
            this->PropertyList_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->PropertyList_parser_)
          {
            ::PropertyListType* tmp = this->PropertyList_parser_->post_PropertyListType ();
            this->PropertyList (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "Text" && ns.empty ())
      {
        if (start)
        {
          if (this->Text_parser_)
          {
            this->Text_parser_->pre ();
            this->Text_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->Text_parser_)
          {
            const ::std::string& tmp = this->Text_parser_->post_string ();
            this->Text (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "Solution" && ns.empty ())
      {
        if (start)
        {
          if (this->Solution_parser_)
          {
            this->Solution_parser_->pre ();
            this->Solution_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->Solution_parser_)
          {
            const ::Solution& tmp = this->Solution_parser_->post_Solution ();
            this->Solution (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for References_pskel.
//
bool References_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "RefSourceList" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &References_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool References_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void References_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void References_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void References_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "RefSourceList" && ns.empty ())
      {
        if (start)
        {
          if (this->RefSourceList_parser_)
          {
            this->RefSourceList_parser_->pre ();
            this->RefSourceList_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->RefSourceList_parser_)
          {
            ::RefSourceList* tmp = this->RefSourceList_parser_->post_RefSourceList ();
            this->RefSourceList (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "RefProposalTypeList" && ns.empty ())
      {
        if (start)
        {
          if (this->RefProposalTypeList_parser_)
          {
            this->RefProposalTypeList_parser_->pre ();
            this->RefProposalTypeList_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->RefProposalTypeList_parser_)
          {
            ::RefProposalTypeList* tmp = this->RefProposalTypeList_parser_->post_RefProposalTypeList ();
            this->RefProposalTypeList (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for Content_pskel.
//
bool Content_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "Category" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &Content_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool Content_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void Content_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void Content_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void Content_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "Category" && ns.empty ())
      {
        if (start)
        {
          if (this->Category_parser_)
          {
            this->Category_parser_->pre ();
            this->Category_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->Category_parser_)
          {
            ::CategoryType* tmp = this->Category_parser_->post_CategoryType ();
            this->Category (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for RefSourceList_pskel.
//
bool RefSourceList_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "Source" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &RefSourceList_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool RefSourceList_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void RefSourceList_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void RefSourceList_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void RefSourceList_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "Source" && ns.empty ())
      {
        if (start)
        {
          if (this->Source_parser_)
          {
            this->Source_parser_->pre ();
            this->Source_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->Source_parser_)
          {
            ::Source* tmp = this->Source_parser_->post_Source ();
            this->Source (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for RefProposalTypeList_pskel.
//
bool RefProposalTypeList_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "jProposalList" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &RefProposalTypeList_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool RefProposalTypeList_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void RefProposalTypeList_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void RefProposalTypeList_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void RefProposalTypeList_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "jProposalList" && ns.empty ())
      {
        if (start)
        {
          if (this->jProposalList_parser_)
          {
            this->jProposalList_parser_->pre ();
            this->jProposalList_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->jProposalList_parser_)
          {
            ::jProposalList* tmp = this->jProposalList_parser_->post_jProposalList ();
            this->jProposalList (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for Source_pskel.
//
bool Source_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "PropertyList" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &Source_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool Source_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void Source_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void Source_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void Source_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "PropertyList" && ns.empty ())
      {
        if (start)
        {
          if (this->PropertyList_parser_)
          {
            this->PropertyList_parser_->pre ();
            this->PropertyList_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->PropertyList_parser_)
          {
            ::PropertyListType* tmp = this->PropertyList_parser_->post_PropertyListType ();
            this->PropertyList (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for jProposalList_pskel.
//
bool jProposalList_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "jProposal" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &jProposalList_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool jProposalList_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void jProposalList_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void jProposalList_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void jProposalList_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "jProposal" && ns.empty ())
      {
        if (start)
        {
          if (this->jProposal_parser_)
          {
            this->jProposal_parser_->pre ();
            this->jProposal_parser_->_pre_impl (ctx);
          }
          else
            ctx.current_.depth_++;
        }
        else
        {
          if (this->jProposal_parser_)
          {
            ::jProposalType* tmp = this->jProposal_parser_->post_jProposalType ();
            this->jProposal (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Attribute validation and dispatch functions for LabelType_pskel.
//
bool LabelType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        unsigned int tmp = this->id_parser_->post_unsigned_int ();

        this->id (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

void LabelType_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.id = false;
  typedef ::xml_schema::string_pskel base;
  base::_pre_a_validate ();
}

void LabelType_pskel::
_post_a_validate ()
{
  typedef ::xml_schema::string_pskel base;
  base::_post_a_validate ();

  if (this->_context ().error_type ())
    return;

  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.id)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for Property_pskel.
//
bool Property_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "key" && ns.empty ())
  {
    if (this->key_parser_)
    {
      this->key_parser_->pre ();

      this->key_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->key_parser_->_characters (s);

      if (!ctx.error_type ())
        this->key_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->key_parser_->post_ncname ();

        this->key (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->key = true;
    return true;
  }

  if (n == "value" && ns.empty ())
  {
    if (this->value_parser_)
    {
      this->value_parser_->pre ();

      this->value_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->value_parser_->_characters (s);

      if (!ctx.error_type ())
        this->value_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->value_parser_->post_string ();

        this->value (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->value = true;
    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

void Property_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.key = false;
  as.value = false;
  typedef ::xml_schema::string_pskel base;
  base::_pre_a_validate ();
}

void Property_pskel::
_post_a_validate ()
{
  typedef ::xml_schema::string_pskel base;
  base::_post_a_validate ();

  if (this->_context ().error_type ())
    return;

  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.key)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.value)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for jProposalType_pskel.
//
bool jProposalType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "mc" && ns.empty ())
  {
    if (this->mc_parser_)
    {
      this->mc_parser_->pre ();

      this->mc_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->mc_parser_->_characters (s);

      if (!ctx.error_type ())
        this->mc_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        bool tmp = this->mc_parser_->post_boolean ();

        this->mc (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->mc = true;
    return true;
  }

  if (n == "qname" && ns.empty ())
  {
    if (this->qname_parser_)
    {
      this->qname_parser_->pre ();

      this->qname_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->qname_parser_->_characters (s);

      if (!ctx.error_type ())
        this->qname_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->qname_parser_->post_id ();

        this->qname (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->qname = true;
    return true;
  }

  return false;
}

void jProposalType_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.mc = false;
  as.qname = false;
}

void jProposalType_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.mc)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.qname)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for Image_pskel.
//
bool Image_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        unsigned int tmp = this->id_parser_->post_unsigned_int ();

        this->id (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
    return true;
  }

  if (n == "uri" && ns.empty ())
  {
    if (this->uri_parser_)
    {
      this->uri_parser_->pre ();

      this->uri_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->uri_parser_->_characters (s);

      if (!ctx.error_type ())
        this->uri_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->uri_parser_->post_uri ();

        this->uri (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->uri = true;
    return true;
  }

  typedef ::xml_schema::string_pskel base;
  return base::_attribute_impl_phase_one (ns, n, s);
}

void Image_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.id = false;
  as.uri = false;
  typedef ::xml_schema::string_pskel base;
  base::_pre_a_validate ();
}

void Image_pskel::
_post_a_validate ()
{
  typedef ::xml_schema::string_pskel base;
  base::_post_a_validate ();

  if (this->_context ().error_type ())
    return;

  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.id)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.uri)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for jGroupType_pskel.
//
bool jGroupType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        unsigned int tmp = this->id_parser_->post_unsigned_int ();

        this->id (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
    return true;
  }

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();

      this->name_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->name_parser_->_characters (s);

      if (!ctx.error_type ())
        this->name_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->name_parser_->post_string ();

        this->name (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
    return true;
  }

  return false;
}

void jGroupType_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.id = false;
  as.name = false;
}

void jGroupType_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.id)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.name)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for CategoryType_pskel.
//
bool CategoryType_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        unsigned long tmp = this->id_parser_->post_non_negative_integer ();

        this->id (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
    return true;
  }

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();

      this->name_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->name_parser_->_characters (s);

      if (!ctx.error_type ())
        this->name_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->name_parser_->post_string ();

        this->name (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
    return true;
  }

  return false;
}

void CategoryType_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.id = false;
  as.name = false;
}

void CategoryType_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.id)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.name)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for SourceRef_pskel.
//
bool SourceRef_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "qnameref" && ns.empty ())
  {
    if (this->qnameref_parser_)
    {
      this->qnameref_parser_->pre ();

      this->qnameref_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->qnameref_parser_->_characters (s);

      if (!ctx.error_type ())
        this->qnameref_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->qnameref_parser_->post_idref ();

        this->qnameref (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for jProposalRef_pskel.
//
bool jProposalRef_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "qnameref" && ns.empty ())
  {
    if (this->qnameref_parser_)
    {
      this->qnameref_parser_->pre ();

      this->qnameref_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->qnameref_parser_->_characters (s);

      if (!ctx.error_type ())
        this->qnameref_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->qnameref_parser_->post_idref ();

        this->qnameref (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->qnameref = true;
    return true;
  }

  return false;
}

void jProposalRef_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.qnameref = false;
}

void jProposalRef_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.qnameref)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for kmx_pskel.
//
bool kmx_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();

      this->name_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->name_parser_->_characters (s);

      if (!ctx.error_type ())
        this->name_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->name_parser_->post_string ();

        this->name (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
    return true;
  }

  if (n == "version" && ns.empty ())
  {
    if (this->version_parser_)
    {
      this->version_parser_->pre ();

      this->version_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->version_parser_->_characters (s);

      if (!ctx.error_type ())
        this->version_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->version_parser_->post_string ();

        this->version (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->version = true;
    return true;
  }

  return false;
}

void kmx_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.name = false;
  as.version = false;
}

void kmx_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.name)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.version)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for Solution_pskel.
//
bool Solution_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "idref" && ns.empty ())
  {
    if (this->idref_parser_)
    {
      this->idref_parser_->pre ();

      this->idref_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->idref_parser_->_characters (s);

      if (!ctx.error_type ())
        this->idref_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        unsigned int tmp = this->idref_parser_->post_unsigned_int ();

        this->idref (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for jProblem_pskel.
//
bool jProblem_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "id" && ns.empty ())
  {
    if (this->id_parser_)
    {
      this->id_parser_->pre ();

      this->id_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->id_parser_->_characters (s);

      if (!ctx.error_type ())
        this->id_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        unsigned int tmp = this->id_parser_->post_unsigned_int ();

        this->id (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
    return true;
  }

  return false;
}

void jProblem_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.id = false;
}

void jProblem_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.id)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for Source_pskel.
//
bool Source_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "qname" && ns.empty ())
  {
    if (this->qname_parser_)
    {
      this->qname_parser_->pre ();

      this->qname_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->qname_parser_->_characters (s);

      if (!ctx.error_type ())
        this->qname_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->qname_parser_->post_id ();

        this->qname (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->qname = true;
    return true;
  }

  if (n == "uri" && ns.empty ())
  {
    if (this->uri_parser_)
    {
      this->uri_parser_->pre ();

      this->uri_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->uri_parser_->_characters (s);

      if (!ctx.error_type ())
        this->uri_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->uri_parser_->post_uri ();

        this->uri (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->uri = true;
    return true;
  }

  return false;
}

void Source_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.qname = false;
  as.uri = false;
}

void Source_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.qname)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.uri)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Begin epilogue.
//
//
// End epilogue.

