// Copyright (C) 2005-2009 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#ifndef KMODEL2_HXX
#define KMODEL2_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsde/cxx/version.hxx>

#if (XSDE_INT_VERSION != 3010000L)
#error XSD/e runtime version mismatch
#endif

#include <xsde/cxx/config.hxx>

#ifndef XSDE_STL
#error the generated code uses STL while the XSD/e runtime does not (reconfigure the runtime or add --no-stl)
#endif

#ifndef XSDE_EXCEPTIONS
#error the generated code uses exceptions while the XSD/e runtime does not (reconfigure the runtime or add --no-exceptions)
#endif

#ifdef XSDE_LONGLONG
#error the XSD/e runtime uses long long while the generated code does not (reconfigure the runtime or remove --no-long-long)
#endif

#include <xsde/cxx/pre.hxx>

#include <string>
#include <xsde/cxx/hybrid/xml-schema.hxx>
#include <xsde/cxx/hybrid/sequence.hxx>

namespace xml_schema
{
  using ::xsde::cxx::hybrid::any_type;
  using ::xsde::cxx::hybrid::any_simple_type;
  typedef signed char byte;
  using ::xsde::cxx::hybrid::byte_base;

  typedef unsigned char unsigned_byte;
  using ::xsde::cxx::hybrid::unsigned_byte_base;

  typedef short short_;
  using ::xsde::cxx::hybrid::short_base;

  typedef unsigned short unsigned_short;
  using ::xsde::cxx::hybrid::unsigned_short_base;

  typedef int int_;
  using ::xsde::cxx::hybrid::int_base;

  typedef unsigned int unsigned_int;
  using ::xsde::cxx::hybrid::unsigned_int_base;

  typedef long long_;
  using ::xsde::cxx::hybrid::long_base;

  typedef unsigned long unsigned_long;
  using ::xsde::cxx::hybrid::unsigned_long_base;

  typedef long integer;
  using ::xsde::cxx::hybrid::integer_base;

  typedef long non_positive_integer;
  using ::xsde::cxx::hybrid::non_positive_integer_base;

  typedef unsigned long non_negative_integer;
  using ::xsde::cxx::hybrid::non_negative_integer_base;

  typedef unsigned long positive_integer;
  using ::xsde::cxx::hybrid::positive_integer_base;

  typedef long negative_integer;
  using ::xsde::cxx::hybrid::negative_integer_base;

  typedef bool boolean;
  using ::xsde::cxx::hybrid::boolean_base;

  typedef float float_;
  using ::xsde::cxx::hybrid::float_base;

  typedef double double_;
  using ::xsde::cxx::hybrid::double_base;

  typedef double decimal;
  using ::xsde::cxx::hybrid::decimal_base;

  typedef ::std::string string;

  typedef ::std::string normalized_string;

  typedef ::std::string token;

  typedef ::std::string name;

  typedef ::std::string nmtoken;

  typedef ::xsde::cxx::string_sequence nmtokens;

  typedef ::std::string ncname;

  typedef ::std::string language;

  typedef ::std::string id;

  typedef ::std::string idref;

  typedef ::xsde::cxx::string_sequence idrefs;

  typedef ::std::string uri;

  using ::xsde::cxx::qname;

  using ::xsde::cxx::buffer;
  typedef ::xsde::cxx::buffer base64_binary;
  typedef ::xsde::cxx::buffer hex_binary;

  using ::xsde::cxx::time_zone;
  using ::xsde::cxx::date;
  using ::xsde::cxx::date_time;
  using ::xsde::cxx::duration;
  using ::xsde::cxx::gday;
  using ::xsde::cxx::gmonth;
  using ::xsde::cxx::gmonth_day;
  using ::xsde::cxx::gyear;
  using ::xsde::cxx::gyear_month;
  using ::xsde::cxx::time;

  using ::xsde::cxx::hybrid::pod_sequence;
  using ::xsde::cxx::hybrid::fix_sequence;
  using ::xsde::cxx::hybrid::var_sequence;
  using ::xsde::cxx::string_sequence;
  using ::xsde::cxx::hybrid::data_sequence;
}

class LabelType;
class Property;
class PropertyListType;
class jProposalType;
class Image;
class ImageListType;
class jGroupType;
class CategoryType;
class SourceRef;
class SourceList;
class jProposalRef;
class jProposal;
class jProblemList;
class kmx;
class Solution;
class jProblem;
class References;
class Content;
class RefSourceList;
class RefProposalTypeList;
class Source;
class jProposalList;

#ifndef XSDE_DONT_INCLUDE_INLINE
#define XSDE_DONT_INCLUDE_INLINE

#undef XSDE_DONT_INCLUDE_INLINE
#else

#endif // XSDE_DONT_INCLUDE_INLINE

// LabelType (fixed-length)
//
class LabelType: public ::std::string
{
  public:
  LabelType ();
  ~LabelType ();
  LabelType (const LabelType&);
  LabelType& operator= (const LabelType&);

  // id
  // 
  unsigned int
  id () const;

  unsigned int&
  id ();

  void
  id (unsigned int);

  private:
  unsigned int id_;
};

// Property (fixed-length)
//
class Property: public ::std::string
{
  public:
  Property ();
  ~Property ();
  Property (const Property&);
  Property& operator= (const Property&);

  // key
  // 
  const ::std::string&
  key () const;

  ::std::string&
  key ();

  void
  key (const ::std::string&);

  // value
  // 
  const ::std::string&
  value () const;

  ::std::string&
  value ();

  void
  value (const ::std::string&);

  private:
  ::std::string key_;
  ::std::string value_;
};

// PropertyListType (variable-length)
//
class PropertyListType
{
  public:
  PropertyListType ();
  ~PropertyListType ();

  private:
  PropertyListType (const PropertyListType&);
  PropertyListType& operator= (const PropertyListType&);

  public:
  // Property
  // 
  typedef ::xsde::cxx::hybrid::fix_sequence< ::Property > Property_sequence;
  typedef Property_sequence::iterator Property_iterator;
  typedef Property_sequence::const_iterator Property_const_iterator;

  const Property_sequence&
  Property () const;

  Property_sequence&
  Property ();

  private:
  Property_sequence Property_;
};

// jProposalType (variable-length)
//
class jProposalType
{
  public:
  jProposalType ();
  ~jProposalType ();

  private:
  jProposalType (const jProposalType&);
  jProposalType& operator= (const jProposalType&);

  public:
  // mc
  // 
  bool
  mc () const;

  bool&
  mc ();

  void
  mc (bool);

  // qname
  // 
  const ::std::string&
  qname () const;

  ::std::string&
  qname ();

  void
  qname (const ::std::string&);

  // Label
  // 
  typedef ::xsde::cxx::hybrid::fix_sequence< ::LabelType > Label_sequence;
  typedef Label_sequence::iterator Label_iterator;
  typedef Label_sequence::const_iterator Label_const_iterator;

  const Label_sequence&
  Label () const;

  Label_sequence&
  Label ();

  private:
  bool mc_;
  ::std::string qname_;
  Label_sequence Label_;
};

// Image (fixed-length)
//
class Image: public ::std::string
{
  public:
  Image ();
  ~Image ();
  Image (const Image&);
  Image& operator= (const Image&);

  // id
  // 
  unsigned int
  id () const;

  unsigned int&
  id ();

  void
  id (unsigned int);

  // uri
  // 
  const ::std::string&
  uri () const;

  ::std::string&
  uri ();

  void
  uri (const ::std::string&);

  private:
  unsigned int id_;
  ::std::string uri_;
};

// ImageListType (variable-length)
//
class ImageListType
{
  public:
  ImageListType ();
  ~ImageListType ();

  private:
  ImageListType (const ImageListType&);
  ImageListType& operator= (const ImageListType&);

  public:
  // Image
  // 
  typedef ::xsde::cxx::hybrid::fix_sequence< ::Image > Image_sequence;
  typedef Image_sequence::iterator Image_iterator;
  typedef Image_sequence::const_iterator Image_const_iterator;

  const Image_sequence&
  Image () const;

  Image_sequence&
  Image ();

  private:
  Image_sequence Image_;
};

// jGroupType (variable-length)
//
class jGroupType
{
  public:
  jGroupType ();
  ~jGroupType ();

  private:
  jGroupType (const jGroupType&);
  jGroupType& operator= (const jGroupType&);

  public:
  // id
  // 
  unsigned int
  id () const;

  unsigned int&
  id ();

  void
  id (unsigned int);

  // name
  // 
  const ::std::string&
  name () const;

  ::std::string&
  name ();

  void
  name (const ::std::string&);

  // PropertyList
  // 
  const ::PropertyListType&
  PropertyList () const;

  ::PropertyListType&
  PropertyList ();

  void
  PropertyList (::PropertyListType*);

  // SourceList
  // 
  bool
  SourceList_present () const;

  void
  SourceList_present (bool);

  const ::SourceList&
  SourceList () const;

  ::SourceList&
  SourceList ();

  void
  SourceList (::SourceList*);

  // Description
  // 
  const ::std::string&
  Description () const;

  ::std::string&
  Description ();

  void
  Description (const ::std::string&);

  // ImageList
  // 
  const ::ImageListType&
  ImageList () const;

  ::ImageListType&
  ImageList ();

  void
  ImageList (::ImageListType*);

  // Text
  // 
  const ::std::string&
  Text () const;

  ::std::string&
  Text ();

  void
  Text (const ::std::string&);

  // Hint
  // 
  const ::std::string&
  Hint () const;

  ::std::string&
  Hint ();

  void
  Hint (const ::std::string&);

  // jProposal
  // 
  const ::jProposal&
  jProposal () const;

  ::jProposal&
  jProposal ();

  void
  jProposal (::jProposal*);

  // jProblemList
  // 
  const ::jProblemList&
  jProblemList () const;

  ::jProblemList&
  jProblemList ();

  void
  jProblemList (::jProblemList*);

  private:
  unsigned int id_;
  ::std::string name_;
  ::PropertyListType* PropertyList_;
  ::SourceList* SourceList_;
  ::std::string Description_;
  ::ImageListType* ImageList_;
  ::std::string Text_;
  ::std::string Hint_;
  ::jProposal* jProposal_;
  ::jProblemList* jProblemList_;
};

// CategoryType (variable-length)
//
class CategoryType
{
  public:
  CategoryType ();
  ~CategoryType ();

  private:
  CategoryType (const CategoryType&);
  CategoryType& operator= (const CategoryType&);

  public:
  // id
  // 
  unsigned long
  id () const;

  unsigned long&
  id ();

  void
  id (unsigned long);

  // name
  // 
  const ::std::string&
  name () const;

  ::std::string&
  name ();

  void
  name (const ::std::string&);

  // PropertyList
  // 
  const ::PropertyListType&
  PropertyList () const;

  ::PropertyListType&
  PropertyList ();

  void
  PropertyList (::PropertyListType*);

  // Description
  // 
  const ::std::string&
  Description () const;

  ::std::string&
  Description ();

  void
  Description (const ::std::string&);

  // Category
  // 
  typedef ::xsde::cxx::hybrid::var_sequence< ::CategoryType > Category_sequence;
  typedef Category_sequence::iterator Category_iterator;
  typedef Category_sequence::const_iterator Category_const_iterator;

  const Category_sequence&
  Category () const;

  Category_sequence&
  Category ();

  // jGroup
  // 
  typedef ::xsde::cxx::hybrid::var_sequence< ::jGroupType > jGroup_sequence;
  typedef jGroup_sequence::iterator jGroup_iterator;
  typedef jGroup_sequence::const_iterator jGroup_const_iterator;

  const jGroup_sequence&
  jGroup () const;

  jGroup_sequence&
  jGroup ();

  private:
  unsigned long id_;
  ::std::string name_;
  ::PropertyListType* PropertyList_;
  ::std::string Description_;
  Category_sequence Category_;
  jGroup_sequence jGroup_;
};

// SourceRef (fixed-length)
//
class SourceRef
{
  public:
  SourceRef ();
  ~SourceRef ();
  SourceRef (const SourceRef&);
  SourceRef& operator= (const SourceRef&);

  // qnameref
  // 
  bool
  qnameref_present () const;

  void
  qnameref_present (bool);

  const ::std::string&
  qnameref () const;

  ::std::string&
  qnameref ();

  void
  qnameref (const ::std::string&);

  private:
  ::std::string qnameref_;
  unsigned char qnameref_present_;
};

// SourceList (variable-length)
//
class SourceList
{
  public:
  SourceList ();
  ~SourceList ();

  private:
  SourceList (const SourceList&);
  SourceList& operator= (const SourceList&);

  public:
  // SourceRef
  // 
  typedef ::xsde::cxx::hybrid::fix_sequence< ::SourceRef > SourceRef_sequence;
  typedef SourceRef_sequence::iterator SourceRef_iterator;
  typedef SourceRef_sequence::const_iterator SourceRef_const_iterator;

  const SourceRef_sequence&
  SourceRef () const;

  SourceRef_sequence&
  SourceRef ();

  private:
  SourceRef_sequence SourceRef_;
};

// jProposalRef (fixed-length)
//
class jProposalRef
{
  public:
  jProposalRef ();
  ~jProposalRef ();
  jProposalRef (const jProposalRef&);
  jProposalRef& operator= (const jProposalRef&);

  // qnameref
  // 
  const ::std::string&
  qnameref () const;

  ::std::string&
  qnameref ();

  void
  qnameref (const ::std::string&);

  private:
  ::std::string qnameref_;
};

// jProposal (variable-length)
//
class jProposal: public ::jProposalType
{
  public:
  jProposal ();
  ~jProposal ();

  private:
  jProposal (const jProposal&);
  jProposal& operator= (const jProposal&);

  public:
  // jProposalRef
  // 
  bool
  jProposalRef_present () const;

  void
  jProposalRef_present (bool);

  const ::jProposalRef&
  jProposalRef () const;

  ::jProposalRef&
  jProposalRef ();

  void
  jProposalRef (const ::jProposalRef&);

  private:
  ::jProposalRef jProposalRef_;
  unsigned char jProposalRef_present_;
};

// jProblemList (variable-length)
//
class jProblemList
{
  public:
  jProblemList ();
  ~jProblemList ();

  private:
  jProblemList (const jProblemList&);
  jProblemList& operator= (const jProblemList&);

  public:
  // jProblem
  // 
  typedef ::xsde::cxx::hybrid::var_sequence< ::jProblem > jProblem_sequence;
  typedef jProblem_sequence::iterator jProblem_iterator;
  typedef jProblem_sequence::const_iterator jProblem_const_iterator;

  const jProblem_sequence&
  jProblem () const;

  jProblem_sequence&
  jProblem ();

  private:
  jProblem_sequence jProblem_;
};

// kmx (variable-length)
//
class kmx
{
  public:
  kmx ();
  ~kmx ();

  private:
  kmx (const kmx&);
  kmx& operator= (const kmx&);

  public:
  // name
  // 
  const ::std::string&
  name () const;

  ::std::string&
  name ();

  void
  name (const ::std::string&);

  // version
  // 
  const ::std::string&
  version () const;

  ::std::string&
  version ();

  void
  version (const ::std::string&);

  // References
  // 
  const ::References&
  References () const;

  ::References&
  References ();

  void
  References (::References*);

  // Content
  // 
  const ::Content&
  Content () const;

  ::Content&
  Content ();

  void
  Content (::Content*);

  private:
  ::std::string name_;
  ::std::string version_;
  ::References* References_;
  ::Content* Content_;
};

// Solution (fixed-length)
//
class Solution
{
  public:
  Solution ();
  ~Solution ();
  Solution (const Solution&);
  Solution& operator= (const Solution&);

  // idref
  // 
  bool
  idref_present () const;

  void
  idref_present (bool);

  unsigned int
  idref () const;

  unsigned int&
  idref ();

  void
  idref (unsigned int);

  private:
  unsigned int idref_;
  unsigned char idref_present_;
};

// jProblem (variable-length)
//
class jProblem
{
  public:
  jProblem ();
  ~jProblem ();

  private:
  jProblem (const jProblem&);
  jProblem& operator= (const jProblem&);

  public:
  // id
  // 
  unsigned int
  id () const;

  unsigned int&
  id ();

  void
  id (unsigned int);

  // PropertyList
  // 
  const ::PropertyListType&
  PropertyList () const;

  ::PropertyListType&
  PropertyList ();

  void
  PropertyList (::PropertyListType*);

  // Text
  // 
  const ::std::string&
  Text () const;

  ::std::string&
  Text ();

  void
  Text (const ::std::string&);

  // Solution
  // 
  typedef ::xsde::cxx::hybrid::fix_sequence< ::Solution > Solution_sequence;
  typedef Solution_sequence::iterator Solution_iterator;
  typedef Solution_sequence::const_iterator Solution_const_iterator;

  const Solution_sequence&
  Solution () const;

  Solution_sequence&
  Solution ();

  private:
  unsigned int id_;
  ::PropertyListType* PropertyList_;
  ::std::string Text_;
  Solution_sequence Solution_;
};

// References (variable-length)
//
class References
{
  public:
  References ();
  ~References ();

  private:
  References (const References&);
  References& operator= (const References&);

  public:
  // RefSourceList
  // 
  const ::RefSourceList&
  RefSourceList () const;

  ::RefSourceList&
  RefSourceList ();

  void
  RefSourceList (::RefSourceList*);

  // RefProposalTypeList
  // 
  const ::RefProposalTypeList&
  RefProposalTypeList () const;

  ::RefProposalTypeList&
  RefProposalTypeList ();

  void
  RefProposalTypeList (::RefProposalTypeList*);

  private:
  ::RefSourceList* RefSourceList_;
  ::RefProposalTypeList* RefProposalTypeList_;
};

// Content (variable-length)
//
class Content
{
  public:
  Content ();
  ~Content ();

  private:
  Content (const Content&);
  Content& operator= (const Content&);

  public:
  // Category
  // 
  typedef ::xsde::cxx::hybrid::var_sequence< ::CategoryType > Category_sequence;
  typedef Category_sequence::iterator Category_iterator;
  typedef Category_sequence::const_iterator Category_const_iterator;

  const Category_sequence&
  Category () const;

  Category_sequence&
  Category ();

  private:
  Category_sequence Category_;
};

// RefSourceList (variable-length)
//
class RefSourceList
{
  public:
  RefSourceList ();
  ~RefSourceList ();

  private:
  RefSourceList (const RefSourceList&);
  RefSourceList& operator= (const RefSourceList&);

  public:
  // Source
  // 
  typedef ::xsde::cxx::hybrid::var_sequence< ::Source > Source_sequence;
  typedef Source_sequence::iterator Source_iterator;
  typedef Source_sequence::const_iterator Source_const_iterator;

  const Source_sequence&
  Source () const;

  Source_sequence&
  Source ();

  private:
  Source_sequence Source_;
};

// RefProposalTypeList (variable-length)
//
class RefProposalTypeList
{
  public:
  RefProposalTypeList ();
  ~RefProposalTypeList ();

  private:
  RefProposalTypeList (const RefProposalTypeList&);
  RefProposalTypeList& operator= (const RefProposalTypeList&);

  public:
  // jProposalList
  // 
  const ::jProposalList&
  jProposalList () const;

  ::jProposalList&
  jProposalList ();

  void
  jProposalList (::jProposalList*);

  private:
  ::jProposalList* jProposalList_;
};

// Source (variable-length)
//
class Source
{
  public:
  Source ();
  ~Source ();

  private:
  Source (const Source&);
  Source& operator= (const Source&);

  public:
  // qname
  // 
  const ::std::string&
  qname () const;

  ::std::string&
  qname ();

  void
  qname (const ::std::string&);

  // uri
  // 
  const ::std::string&
  uri () const;

  ::std::string&
  uri ();

  void
  uri (const ::std::string&);

  // PropertyList
  // 
  const ::PropertyListType&
  PropertyList () const;

  ::PropertyListType&
  PropertyList ();

  void
  PropertyList (::PropertyListType*);

  private:
  ::std::string qname_;
  ::std::string uri_;
  ::PropertyListType* PropertyList_;
};

// jProposalList (variable-length)
//
class jProposalList
{
  public:
  jProposalList ();
  ~jProposalList ();

  private:
  jProposalList (const jProposalList&);
  jProposalList& operator= (const jProposalList&);

  public:
  // jProposal
  // 
  typedef ::xsde::cxx::hybrid::var_sequence< ::jProposalType > jProposal_sequence;
  typedef jProposal_sequence::iterator jProposal_iterator;
  typedef jProposal_sequence::const_iterator jProposal_const_iterator;

  const jProposal_sequence&
  jProposal () const;

  jProposal_sequence&
  jProposal ();

  private:
  jProposal_sequence jProposal_;
};

#ifndef XSDE_DONT_INCLUDE_INLINE

#endif // XSDE_DONT_INCLUDE_INLINE

#ifndef XSDE_DONT_INCLUDE_INLINE
#include "kmodel2.ixx"
#endif // XSDE_DONT_INCLUDE_INLINE

#include <xsde/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // KMODEL2_HXX
